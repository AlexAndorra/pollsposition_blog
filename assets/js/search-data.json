{
  
    
        "post0": {
            "title": "How popular is the President?",
            "content": "I like working on time series, because they usually relate to something concrete. I&#39;ve also long been intrigued by Gaussian Processes -- they have a mathematical beauty and versatility that I&#39;ve always found intriguing, if only because you can parametrize the model in ways where you can interpret it. . But... they are hard to fit -- the number of gradient computation scales with the cube of the number of data points. And in the Bayesian framework, we&#39;re trying to estimate the whole distribution of outcomes, not only one single point, which adds to the challenge. . One thing I learned so far in my open-source programming journey is not to be afraid of what you&#39;re afraid of -- to what you&#39;ll legitimately answer: &quot;wait, what??&quot;. Let me rephrase: if a method scares you, the best way to understand it is to work on an example where you need it. This will dissipate (part of) the magic behind it and help you cross a threshold in your understanding. . So that&#39;s what I did with Gaussian Processes! That all came from a simple question: how does the popularity of French presidents evolve within term and across terms? I often hear people frenetically commenting the latest popularity poll (frequently the same people who later will complain that &quot;polls are always wrong&quot;, but that&#39;s another story), and in these cases I&#39;m always worried that we&#39;re reacting to noise -- maybe it&#39;s just natural that a president experiences a dip in popularity at the middle of his term? . To answer this question, I compiled all the popularity opinion polls of French presidents since the term limits switched to 5 years (in 2002). Let&#39;s see what the data look like, before diving into the Gaussian Process model. . Show me the data! . Here are the packages we&#39;ll need: . import arviz as az import matplotlib.pyplot as plt import numpy as np import pandas as pd import pymc3 as pm import xarray as xr from scipy.special import expit as logistic . Now, let&#39;s load up the data in a dataframe called d. You&#39;ll notice that, in addition to the polling data, the dataframe also contains the quarterly unemployment rate in France (downloaded from the French statistical office). As this variable is usually well correlated with politicians&#39; and parties&#39; popularity, we will use it as a predictor in our model. . As I&#39;ll explain below, we&#39;re computing the popularity every month, but since unemployment data are released quarterly, we just forward-fill the unemployment values when they are missing -- which is, I insist, an assumption, and as such it should be tested and played with, to check its impact on the model&#39;s inferences (there is a Binder and Google Collab link at the top of the page, so feel free to do so!). I could also use more intricate techniques to forecast unemployment, but that would be an overkill for our purpose here. . quarter president samplesize p_approve p_disapprove party election_flag N_approve N_disapprove N_total unemployment . month . 2002-05-31 2002Q2 | chirac2 | 964.250000 | 0.502500 | 0.442500 | right | 1 | 485 | 427 | 912 | 7.5 | . 2002-06-30 2002Q2 | chirac2 | 970.000000 | 0.505000 | 0.425000 | right | 0 | 490 | 412 | 902 | 7.5 | . 2002-07-31 2002Q3 | chirac2 | 947.333333 | 0.533333 | 0.406667 | right | 0 | 505 | 385 | 890 | 7.5 | . 2002-08-31 2002Q3 | chirac2 | 1028.000000 | 0.520000 | 0.416667 | right | 0 | 535 | 428 | 963 | 7.5 | . 2002-09-30 2002Q3 | chirac2 | 1017.500000 | 0.525000 | 0.420000 | right | 0 | 534 | 427 | 961 | 7.5 | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 2020-09-30 2020Q3 | macron | 1000.500000 | 0.320000 | 0.625000 | center | 0 | 320 | 625 | 945 | 8.8 | . 2020-10-31 2020Q4 | macron | 1000.000000 | 0.373333 | 0.573333 | center | 0 | 373 | 573 | 946 | 8.8 | . 2020-11-30 2020Q4 | macron | 1188.000000 | 0.384000 | 0.586000 | center | 0 | 456 | 696 | 1152 | 8.8 | . 2020-12-31 2020Q4 | macron | 1000.000000 | 0.320000 | 0.640000 | center | 0 | 320 | 640 | 960 | 8.8 | . 2021-01-31 2021Q1 | macron | 1014.500000 | 0.400000 | 0.580000 | center | 0 | 406 | 588 | 994 | 8.8 | . 225 rows √ó 11 columns . If you go check the raw underlying notebook, you&#39;ll see that there is a bunch of data cleaning involved to get to that format. The most important is that we perform a simple monthly average to get fixed time intervals, which makes computation easier for the GP -- and it&#39;s actually not that far-fetched to consider that we get to &quot;observe&quot; the president&#39;s popularity only once a month, thanks to the average of all polls taken in this month. . Ideally though, we wouldn&#39;t do that, as 1) it breaks the purely generative aspect of the model (now the model doesn&#39;t take as observations the raw polls but their average), and 2) it tricks the model into believing that the dispersion in polls is lower than it actually is. . As a first implementation though, let&#39;s make our lives easier and see how that goes -- we can always go back to the model and relax this assumption if needed. . Speaking of making our lives easier, let&#39;s write a helper function to convert datetimes to numbers, in reference to a given date. This will be useful to use time as a predictor in our model -- more precisely, as an input to our GP (completely lost? Don&#39;t worry, we&#39;ll get back to that). . def dates_to_idx(timelist): &quot;&quot;&quot;Convert datetimes to numbers in reference to a given date&quot;&quot;&quot; reference_time = timelist[0] t = (timelist - reference_time) / np.timedelta64(1, &quot;M&quot;) return np.asarray(t) time = dates_to_idx(d.index) time[:10] . array([0. , 0.98564652, 2.00414793, 3.02264934, 4.00829586, 5.02679726, 6.01244379, 7.03094519, 8.0494466 , 8.96938335]) . Let&#39;s also define a function to standardize data (mean 0 and standard deviation 1), which we&#39;ll use for our only continuous predictor, the unemployment rate. Indeed that will make it easier to set our priors for the coefficient associated to unemployment, and our sampler will have a better time sampling -- so, you know two üê¶ with one üíé ! . def standardize(series): &quot;&quot;&quot;Standardize a pandas series&quot;&quot;&quot; return (series - series.mean()) / series.std() . Build me a model . Now is time to define the model, which should make things clearer. The polls are, quite simply, realizations of a Binomial distribution: for each poll, a number $n$ of people are surveyed, and $y$ of them say they approve of the president&#39;s job. Note that we ignore those who report no opinion, because their numbers are usually negligeable, so $n - y$ represents the number of people who disapprove of the president&#39;s job. Statistically speaking, we have $y sim Binomial(n, p)$, where $p$ equals the proportion of people supporting the president. . $p$ is really what we&#39;re after here: given the observed polls, what is our inference of the true, latent support of the president in the population? But I can feel that something is bothering you, isn&#39;t it (yeah, I can read minds)? Right now you&#39;re thinking: &quot;but aren&#39;t polls noisy observations of reality&quot;? To what I&#39;ll answer: &quot;boy, you&#39;re really good at this!&quot;. Polls are indeed noisy estimates and a variety of factors account for these polling errors. . So, we need to take that into account, and a quick way to do that is to use the Beta-Binomial distribution, which handles overdispersed data -- i.e observations that are more variable than a classic Binomial distribution would expect and can accomodate. If you want more details about these models (poetically named &quot;continuous mixture models&quot;), I&#39;d refer you to chapter 12 of Richard McElreath&#39;s excellent Statistical Rethinking. . In the Beta-Binomial distribution, the Binomial probabilities are no longer fixed, but are rather random variables drawn from a common Beta distribution. So, in addition to the number of trials, $n$, Beta-Binomial distributions are parametrized by two strictly positive reals, $ alpha$ and $ beta$, which control the Beta distribution. . The thing is that $ alpha$ and $ beta$ usually don&#39;t have a real meaning, so it&#39;s often easier to parametrize the Beta distribution with two other parameters, $p$ and $ theta$, which roughly correspond to the mean and precision respectively: for a given $p$, a higher $ theta$ means that we are more skeptical of very weak or very strong probabilities -- those near 0 or 1. . We don&#39;t need a prior on $p$, as it will be a deterministic function of our regression. But we do need one for $ theta$. A value of 2 translates in a uniform prior over probabilities, which is not what we want -- we know presidential approval never goes below 10% and above 90% (at least in France). To get that, we can set $ theta = 10$. You can play around with the code below to get a sense of how the Beta family behaves: . x_plot = np.linspace(0, 1, 100) pbar = 0.5 theta = 10.0 plt.plot( x_plot, np.exp(pm.Beta.dist(pbar * theta, (1 - pbar) * theta).logp(x_plot).eval()), label=f&quot;Beta({pbar * theta}, {(1 - pbar) * theta})&quot;, ) plt.xlabel(&quot;Probablity&quot;) plt.ylabel(&quot;Density&quot;) plt.legend(); . Looks good right? And you can see that the mathematical link between $(p, theta)$ and $( alpha, beta)$ is quite simple: . $$ alpha = p times theta $$ $$ beta = (1 - p) times theta $$ . So, we want to assume that the precision is at least 10. To that end, we can use a trick and define $ theta = tilde{ theta} + 10$, where $ tilde{ theta} sim Exponential(1)$, which works because exponential distributions have a minimum of zero. . Let&#39;s turn our attention to $p$ now, the parameter we really care about. We model it through the addition of a linear component ($baseline + beta_{honeymoon} times election _ flag + beta_{unemp} times unemp _ data$ and a non-parametric component (the GP, $f _time$). The GP basically allows us to tell the model that time and popularity covary, but we don&#39;t know the exact functional form of this romantic relationship, so we&#39;d like the model to figure it out for us -- yep, GPs are pretty cool; I bet they were popular in college! To make sure $p$ stays between 0 and 1 (it&#39;s a probability, remember?), we use the logistic link function. . We now have all the parts to build our model! We just need to define the priors for all our unknown parameters. That what we&#39;ll do in the next section, but first, let&#39;s assemble all the building blocks, to contemplate our beautiful inference machine (yeah, I took a couple poetry classes in highschool): . $$y sim BetaBinomial( alpha=p times theta, : beta=(1 - p) times theta, : n)$$ . $$theta sim¬†Exponential(1) + 10$$ . $$p = logistic(baseline + f _ time + beta_{honeymoon} times election _ flag + beta_{unemp} times log(unemp _ data))$$ . $$baseline sim Normal(-0.7, 0.5)$$ . $$ beta_{honeymoon} sim Normal(-0.5, 0.3)$$ . $$ beta_{unemp} sim Normal(0, 0.2)$$ . $$f _ time sim GP(0, Sigma)$$ . $$ Sigma = amplitude^2 times Matern52(length _ scale)$$ . $$amplitude sim HalfNormal(1)$$ . $$length _ scale sim Gamma( alpha=5, beta=2)$$ . As I know you&#39;re very attentive, you have noticed that we use the logarithm of unemployment, not the raw unemployment rate. It&#39;s because we think that what matters for citizens when they think about unemployment is its order of magnitude, not its absolute values. . Other than that, the model should look pretty familiar to you now -- well, except for the priors on the GP and the coefficients. So, let&#39;s turn to that right now! . Time to choose... your GP prior . Priors are very important to fit GPs properly, so let&#39;s spend some time thinking about our priors for a more refined model of the popularity of the president. Note that this is a tutorial about how to code up a GP in PyMC3, not a tutorial about the theory of GPs, so we assume familiarity with the concepts. If you need a refresher about the theory, take a look at PyMC3&#39;s Mauna Loa notebook, Michael Betancourt&#39;s excellent case study and chapter 21 of Bayesian Data Analysis. . Kernel relations . We will use a fairly common Matern 5/2 kernel. It has the advantage of being less smooth than the classic exponentiated quadratic kernel, which is useful here as the GP must be able to jump from one regime to another very quickly when a new president is sworn in (you&#39;ll see that the swing in popularity is usually very wide). . We could probably do something better here by signaling these change points to our GP (after all, we know when a new president comes in, so we should tell it to our model). That way, we could use different kernels for each president. Or we could look into non-stationary kernels: the Matern kernel is stationary, meaning that the estimated covariance between data points doesn&#39;t vary depending on the period we&#39;re in -- maybe French people&#39;s assessment of their presidents varied less (i.e was more autocorrelated) in the 2000s, when there were no 24/7 TV news networks? . In short, it&#39;s easy to imagine that the way popularity varies with time (which is what our GP tries to capture) itself varies according to the president&#39;s personality and the times he lived in. The improvements above would integrate this assumption into the model. But, again, this is a first version -- let&#39;s see if, like the 2019 Nobel Chemistry prize, it&#39;s good enough. . Amplitude -- Don&#39;t go so high! . The Matern 5/2 kernel is parametrized with an amplitude and a length scale. The amplitude controls, quite surprisingly, the amplitude of the GP realized values: the bigger the amplitude, the larger the variations in the GP values. You can think of it as the $y$ axis in the plots you will see below -- the range of values that $f(x)$ can take on, $f$ being drawn from the GP. . Proportions in polls vary from 0 to 1, and the GP models only part of the variation in polls. We will also standardize our predictor (unemployment data), which means it will have a standard deviation of 1. So, in this context, $Halfnormal(1)$ should be a weakly regularizing prior. . Length scale -- Don&#39;t go so far! . I know you&#39;re quite impatient, so I already hear you asking: &quot;what about the length scale now?&quot;. Well, ok! But do you even know what that controls? The length scale can be interpreted as the degree of correlation between the GP values: the higher it is, the smoother the functions drawn from the GP, because their realized values will be highly correlated. In a way, you can think of the length scale as the maximum distance on the $x$ axis at which two points in time still share information. . In our case, we can imagine that polls taken 3 months ago still have a bit of influence on today&#39;s results, but it&#39;s probably not the case for polls from more than 6 months ago. So we need a prior that&#39;s both avoiding 0 (by definition, it never makes sense for the length scale to be exactly 0) and constraining values above about 6 months. The Gamma family of distributions is usually a helpful choice here, as it is very versatile and has support over the positive real line. Here are a few examples, to give you an idea: . x = np.linspace(0, 120, 500) priors = [ (r&quot;$ alpha$=5, $ beta$=2&quot;, pm.Gamma.dist(alpha=5, beta=2)), (r&quot;$ alpha$=2, $ beta$=0.5&quot;, pm.Gamma.dist(alpha=2, beta=0.5)), (r&quot;$ alpha$=9, $ beta$=1&quot;, pm.Gamma.dist(alpha=9, beta=1)), (r&quot;$ alpha$=20, $ beta$=1&quot;, pm.Gamma.dist(alpha=20, beta=1)), ] fig = plt.figure() for i, prior in enumerate(priors): plt.plot(x, np.exp(prior[1].logp(x).eval()), label=prior[0]) plt.xlim((-1, 40)) plt.xlabel(&quot;Months&quot;) plt.ylabel(&quot;Density&quot;) plt.title(&quot;Length scale priors&quot;) plt.legend(); . . The blue line, representing $Gamma(5, 2)$ has our favors, because most of the probability mass is between 0 and 6 months, which we deemed reasonable above. . If you&#39;re a bit lost, that&#39;s quite normal: GPs are rather meta, so it takes some time to develop intuition about them. A nice thing though is that we can relate the GP&#39;s parameters to the reality of our use-case, which makes it more interpretable. . In any case, take your time going through this, and understanding will come. This notebook about mean and covariance functions and this case study are good educational ressources to think about priors in the context of GPs. . Putting the GP together -- You&#39;re beautiful! . The best we can do now to make this more concrete is to draw some functions from our GP, prior to seeing any data. That will help us understand our model and determine if our prior choices make sense. This is pretty simple to do with PyMC3: . amplitude_trend = pm.HalfNormal.dist(1.0).random(1) ls_trend = pm.Gamma.dist(alpha=5, beta=2).random(1) cov_trend = amplitude_trend ** 2 * pm.gp.cov.Matern52(1, ls_trend) prior_timepoints = np.linspace(0, 60, 200)[:, None] K = cov_trend(prior_timepoints).eval() gp_prior_samples = pm.MvNormal.dist(mu=np.zeros(K.shape[0]), cov=K).random(size=20_000) . _, (left, mid, right) = plt.subplots( 1, 3, figsize=(14, 5), constrained_layout=True, sharex=True, sharey=True ) for ax, samples in zip((left, mid, right), (5, 10, 100)): ax.plot( prior_timepoints, gp_prior_samples[:samples].T, color=&quot;darkblue&quot;, alpha=0.3, ) ax.set_title(&quot;Samples from the GP prior&quot;) ax.set_xlabel(&quot;Time in months&quot;) ax.set_ylabel(&quot;Popularity evolution&quot;); . Each line is a realization of the GP prior. We indeed see the effect of our priors on both the amplitude and length scale, with most functions fluctuating between -1 and 1 (amplitude) and the auto-correlation being limited to around 6 months (length scale). . As we didn&#39;t specify a mean for our GP, PyMC by default centers it at 0, which happens to also be what we want: the GP is here to capture the residual variation of popularity once we&#39;ve taken into effect the baseline, unemployment and honeymoon effects. . The &quot;spaghetti&quot; plots above are useful to get an idea of individual functions and the correlations between their values, but it&#39;s hard to understand exactly where different quantiles end up. To get that information, &quot;ribbon&quot; plots are more interesting. Let&#39;s compute and display the median, 40-60%, 30-70%, 20-80% and 10-90% quantile intervals of the GP prior samples we already drew above: . /Users/alex_andorra/opt/anaconda3/envs/elections-models/lib/python3.8/site-packages/arviz/stats/stats.py:484: FutureWarning: hdi currently interprets 2d data as (draw, shape) but this will change in a future release to (chain, draw) for coherence with other functions warnings.warn( /Users/alex_andorra/opt/anaconda3/envs/elections-models/lib/python3.8/site-packages/arviz/stats/stats.py:484: FutureWarning: hdi currently interprets 2d data as (draw, shape) but this will change in a future release to (chain, draw) for coherence with other functions warnings.warn( /Users/alex_andorra/opt/anaconda3/envs/elections-models/lib/python3.8/site-packages/arviz/stats/stats.py:484: FutureWarning: hdi currently interprets 2d data as (draw, shape) but this will change in a future release to (chain, draw) for coherence with other functions warnings.warn( /Users/alex_andorra/opt/anaconda3/envs/elections-models/lib/python3.8/site-packages/arviz/stats/stats.py:484: FutureWarning: hdi currently interprets 2d data as (draw, shape) but this will change in a future release to (chain, draw) for coherence with other functions warnings.warn( . Easier to visualize the different expectations, right? Let&#39;s note though that these plots ignore the correlation between time points, so they underestimate the overall variation in the GP samples -- and indeed you can see that the $y$ axis is on a smaller scale than the spaghetti plots&#39;. . But wait, there is more... priors to choose . Enjoying it so far? Of course you are! Well good news: we still have priors to pick for the intercept, honeymoon and unemployment effects üçæ . Our regression intercept is also the mean function of our GP -- the value it reverts to when data start lacking. There, we have quite a lot of information: 50% popularity is historically high for a French president, so keeping the mean at zero is sub-optimal -- our parameter lives on the logit scale, so a prior centered at 0 means a prior centered at $logistic(0) = 0.5$ on the outcome space. . We can do better: based on our domain knowledge, we expect most presidents to have a baseline popularity between 20% and 50% -- in other words, French people rarely love their presidents but often really dislike them. $Normal(-0.7, 0.5)$ looks reasonable in that regard: it expects 95% of the probability mass to be between -1.7 and 0.3, i.e $logistic(-1.7) = 15 %$ and $logistic(0.3) = 57 %$, with a mean approval of $logistic(-0.7) = 33 %$: . Similarly, we have a lot of domain knowledge about the honeymoon effect -- the bump in popularity that a newly elected president gets when taking office. Here again, we have a lot of domain knowledge: we should not be surprised by big bumps, since it&#39;s not uncommon to see the outgoing president around 20-30% popularity and the new one around 60%. So, an effect centered around 40% and allowing for lower and larger effects seems appropriate: . For the unemployment effect though, we should expect a much milder effect. First, because socio-demographic variables usually have small effects in the litterature. Second, because unemployment is not the only thing influencing voters&#39; opinion of the president: there is also, notably, partisanship, which makes movements in popularity less responsive to unemployment -- if you really don&#39;t like the president, you probably need to see a very low unemployment rate before starting to credit him. Finally, people probably don&#39;t know the exact current value of unemployment! They just have a fuzzy memory of where it stands -- also potentially influenced by their partisanship. . The beauty of the Bayesian framework is that we can integrate that uncertainty easily in our model: just consider the unemployment rate as a random variable! So, in practice, we put a probability distribution on the unemployment data: . $$u _uncert = log(unemp _ data) + u _diff$$ $$u _diff sim Normal(0, 0.1)$$ . Concretely, that means that unemployment is the result of the data we observe, plus some random noise around it, which conveys the uncertainty in people&#39;s mind. Why $ sigma = 0.1$ for $u _diff$, you ask? Well, data are standardized, so 0.1 is equivalent to 10% of the data&#39;s standard deviation. Since we&#39;re using a Normal distribution, this prior means that 95% of the time, we expect the &quot;true&quot; unemployment rate (the one that people have in mind when thinking about it) is equal to the observed rate $ pm , 0.2$, which seems reasonable when the observations are standardized. . All in all, we expect the unemployment to have a small negative effect, but we&#39;re not sure. So, let&#39;s center our prior on $0$ (i.e no expected effect) and use a weakly regularizing $ sigma$ (in log-odds space): $ beta_{unemp} sim Normal(0, 0.2)$. To see the effect of this prior, we have to plug it into the formula for our model, $popularity = logistic(baseline + f _ time + beta_{unemp} times u _uncert$ (we don&#39;t care about the honeymoon effect here, because the GP is already very flexible when it&#39;s not constrained by data, so you won&#39;t see a difference anyway). . We just have to generate fake unemployment data. Again, as we standardized the real data, simulating data between -3 and 3 is largely sufficient to cover the whole range of possible data: . unemp_effect_prior_samples = pm.Normal.dist(0.0, 0.2).random(size=20_000) fake_unemp = np.linspace(-3, 3, 200)[None, :] prior_approval = logistic( baseline_prior_samples[:, None] + gp_prior_samples + unemp_effect_prior_samples[:, None] * fake_unemp ) . Again, each line is a possible path for any president&#39;s approval, but this time it&#39;s not only the residual variation captured by the GP -- it&#39;s the total popularity of the president and its evolution with time. You can see that there are a lot of different paths -- a bit too many to my taste, if I&#39;m being honest. But this will be the case as long as we need a very flexible kernel to accomodate the boundary effects due to changes of presidents. It&#39;s ok for now, but if the model has troubles sampling or if we want to improve it, that&#39;s definitely one of the first things I&#39;d look at. . Now let&#39;s have a look at the marginal quantiles plot (aka ribbon plot): . /Users/alex_andorra/opt/anaconda3/envs/elections-models/lib/python3.8/site-packages/arviz/stats/stats.py:484: FutureWarning: hdi currently interprets 2d data as (draw, shape) but this will change in a future release to (chain, draw) for coherence with other functions warnings.warn( /Users/alex_andorra/opt/anaconda3/envs/elections-models/lib/python3.8/site-packages/arviz/stats/stats.py:484: FutureWarning: hdi currently interprets 2d data as (draw, shape) but this will change in a future release to (chain, draw) for coherence with other functions warnings.warn( /Users/alex_andorra/opt/anaconda3/envs/elections-models/lib/python3.8/site-packages/arviz/stats/stats.py:484: FutureWarning: hdi currently interprets 2d data as (draw, shape) but this will change in a future release to (chain, draw) for coherence with other functions warnings.warn( /Users/alex_andorra/opt/anaconda3/envs/elections-models/lib/python3.8/site-packages/arviz/stats/stats.py:484: FutureWarning: hdi currently interprets 2d data as (draw, shape) but this will change in a future release to (chain, draw) for coherence with other functions warnings.warn( . This looks good, although it underestimates the total variation again. The tilt downwards at the boundaries is probably due to a combination of the distortion effect of the logistic link function, the rarity of data at the boundaries (which forces the model to revert to our baseline), and our baseline prior putting lots of probability mass below the baseline. And this is what we want actually: presidents spend more time around or below the baseline than above. The improvement we could make though is to tell the model that popularity should trend downwards for each term (i.e higher at the beginning than at the end). Again, we&#39;d probably need a periodic kernel for that. . Coding up the model -- Show time! . We now have everything to set up our model in PyMC3! As you&#39;ll see, it matches up the latex formulation we saw earlier quite well. There are just two novelties, to make our lives easier: we&#39;re using the coords and dims arguments instead of shape; that way, we&#39;ll get to select the data returned by our model with names instead of raw dimensions. Second, we&#39;re using the pm.Data container, to make the model aware of the data we passed; this will make posterior predictions easier down the line. . COORDS = {&quot;timesteps&quot;: d.index} with pm.Model(coords=COORDS) as econ_latent_gp: # intercept on logit scale baseline = pm.Normal(&quot;baseline&quot;, -0.7, 0.5) # honeymoon slope honeymoon = pm.Normal(&quot;honeymoon&quot;, -0.5, 0.3) # log unemployment slope log_unemp_effect = pm.Normal(&quot;log_unemp_effect&quot;, 0.0, 0.2) # long term trend amplitude_trend = pm.HalfNormal(&quot;amplitude_trend&quot;, 1.0) ls_trend = pm.Gamma(&quot;ls_trend&quot;, alpha=5, beta=2) cov_trend = amplitude_trend ** 2 * pm.gp.cov.Matern52(1, ls_trend) # instantiate gp gp = pm.gp.Latent(cov_func=cov_trend) # evaluate GP at time points f_time = gp.prior(&quot;f_time&quot;, X=time[:, None]) # data election_flag = pm.Data(&quot;election_flag&quot;, d.election_flag.values, dims=&quot;timesteps&quot;) stdz_log_unemployment = pm.Data( &quot;stdz_log_unemployment&quot;, standardize(np.log(d.unemployment)).values, dims=&quot;timesteps&quot;, ) # unemployment data is uncertain # sd = 0.1 says uncertainty on point expected btw 20% of data std 95% of time u_diff = pm.Normal(&quot;u_diff&quot;, mu=0.0, sigma=0.1, dims=&quot;timesteps&quot;) u_uncert = stdz_log_unemployment + u_diff # overdispersion parameter theta = pm.Exponential(&quot;theta_offset&quot;, 1.0) + 10.0 p = pm.Deterministic( &quot;p&quot;, pm.math.invlogit( baseline + f_time + honeymoon * election_flag + log_unemp_effect * u_uncert ), dims=&quot;timesteps&quot;, ) y = pm.BetaBinomial( &quot;y&quot;, alpha=p * theta, beta=(1.0 - p) * theta, n=d.N_total, observed=d.N_approve, dims=&quot;timesteps&quot;, ) . And now is the time to actually run our model ü•≥ We&#39;ll run 8 chains and draw 2000 samples in each of them. This is good practice because 1) each chain is quite long, so it should be able to eventually explore problematic regions if there are any, and 2) each chain starts its exploration at a different point in space, increasing our chances to explore all the typical set. . with econ_latent_gp: trace_econ = pm.sample( draws=2000, chains=8, cores=8, return_inferencedata=True, idata_kwargs={ &quot;dims&quot;: {&quot;f_time&quot;: [&quot;timesteps&quot;], &quot;f_time_rotated_&quot;: [&quot;timesteps&quot;]} }, ) . Auto-assigning NUTS sampler... Initializing NUTS using jitter+adapt_diag... Multiprocess sampling (8 chains in 8 jobs) NUTS: [theta_offset, u_diff, f_time_rotated_, ls_trend, amplitude_trend, log_unemp_effect, honeymoon, baseline] . . 100.00% [24000/24000 19:45&lt;00:00 Sampling 8 chains, 0 divergences] Sampling 8 chains for 1_000 tune and 2_000 draw iterations (8_000 + 16_000 draws total) took 1202 seconds. . Diagnosing the model -- What&#39;s wrong with you?? . This is looking good! No warnings, no divergences and a really decent sampling time: 24,000 samples in 20 min (including tuning, which takes always longer), i.e 20 draws per second -- for a GP, this is really good! . So, we have no red flags here. This doesn&#39;t mean our model is good yet, but it increases the chances that it is. Let&#39;s look at the trace plot now, to make sure sampling did go well: . az.plot_trace( trace_econ, compact=True, var_names=[&quot;~u_diff&quot;, &quot;~p&quot;, &quot;~f_time&quot;, &quot;~f_time_rotated_&quot;] ); . az.plot_trace( trace_econ, var_names=[&quot;u_diff&quot;, &quot;p&quot;, &quot;f_time&quot;], compact=True, coords={&quot;timesteps&quot;: trace_econ.observed_data.timesteps[:110]}, ); . Well indeed, that looks good! The chains are mixing well for all parameters, as indicated by the KDEs (leftmost plot), and they show a random walk behavior, as evidenced by the &quot;caterpillars&quot; on the rightmost plot. . Tip: Want more details about trace plots? This blog post is really good üëå . Now let&#39;s look at the pair plot, to see if our posterior distributions exhibit high correlations or, worse, nasty funnel degeneracies üò± . az.plot_pair( trace_econ, var_names=[&quot;~u_diff&quot;, &quot;~p&quot;, &quot;~f_time&quot;, &quot;~f_time_rotated_&quot;], divergences=True, ); . Again, this is all looking good! Almost all plots look like fuzzy balls (so, don&#39;t show this plot to your cat!), hinting that there are no particular posterior correlations between our parameters. We see though that there could be a problem for high values of amplitude_trend and ls_trend (the two parameters of our GP kernel), for a reason that we would have to investigate. But since we&#39;ve thought hard about those priors beforehand and happened to choose distributions skeptical of high values, it seems that we were able to prevent those degeneracies from happening -- Minority Report style ü§ô . Everything seems to be going well here, but just for fun, let&#39;s use one of ArviZ&#39;s latest features and display the rank plot! . az.plot_rank(trace_econ, var_names=[&quot;~u_diff&quot;, &quot;~p&quot;, &quot;~f_time&quot;, &quot;~f_time_rotated_&quot;]); . &quot;That looks cool Alex... but how do I read that?&quot; ü§î Well, as stated in the original paper: . Rank plots are histograms of the ranked posterior draws (ranked over all chains) plotted separately for each chain. If all of the chains are targeting the same posterior, we expect the ranks in each chain to be uniform, whereas if one chain has a different location or scale parameter, this will be reflected in the deviation from uniformity. If rank plots of all chains look similar, this indicates good mixing of the chains. . And here, our rank plots look pretty uniform, so, again, we&#39;re all good! By the way, if you want an example of rank plots indicating problems, look at the examples on this page üòâ . Predicting popularity -- I see the future! . Plots and diagnostics are good to show us if there was a computational issue in our model, but they don&#39;t tell us if our model is good at predicting whatever it&#39;s supposed to predict. That part is always very specific to the model and use-case at hand, so there is no universal method. We could look at the summary table of our coefficients&#39; posterior: . az.summary( trace_econ, var_names=[&quot;~u_diff&quot;, &quot;~p&quot;, &quot;~f_time&quot;, &quot;~f_time_rotated_&quot;], round_to=2 ) . mean sd hdi_3% hdi_97% mcse_mean mcse_sd ess_mean ess_sd ess_bulk ess_tail r_hat . baseline -0.54 | 0.11 | -0.75 | -0.33 | 0.00 | 0.00 | 11032.88 | 10531.30 | 11332.08 | 9104.29 | 1.0 | . honeymoon 0.37 | 0.14 | 0.11 | 0.63 | 0.00 | 0.00 | 25628.14 | 21963.41 | 25654.04 | 11571.46 | 1.0 | . log_unemp_effect -0.12 | 0.07 | -0.26 | 0.02 | 0.00 | 0.00 | 11594.78 | 11594.78 | 11697.90 | 9922.54 | 1.0 | . amplitude_trend 0.43 | 0.07 | 0.32 | 0.56 | 0.00 | 0.00 | 5574.96 | 5215.63 | 6164.58 | 6890.74 | 1.0 | . ls_trend 6.17 | 1.01 | 4.39 | 8.11 | 0.01 | 0.01 | 5601.72 | 5426.55 | 5836.45 | 7198.35 | 1.0 | . theta_offset 50.41 | 6.55 | 38.65 | 63.15 | 0.05 | 0.04 | 17198.27 | 16606.33 | 17395.18 | 11463.88 | 1.0 | . But then you&#39;d say: &quot;uh, yeah... what does that mean? What&#39;s the relationship with popularity?&quot;. And you&#39;d be right: apart from giving us an idea of the direction and magnitude of the covariance between each parameter (all the other held constant) and the president&#39;s popularity, a simple summary table doesn&#39;t convey much. . We can use it as a &quot;gut check&quot; though: the mean baseline popularity across time is $logistic(-0.54) = 0.37$. The honeymoon effect is indeed inferred to be positive, while an increase in unemployment is associated with a slight decrease in popularity. All these inferences are consistent with our domain knowledge -- no üö© . The best way to make sense of all this though is to predict on new data (i.e &quot;out-of-sample&quot;) and visualize these predictions. So let&#39;s predict three months out-of-sample! For this, we need the time data: . MAX_OBSERVED = len(d.index) OOS_MONTHS = 3 # 1 quarter out-of-sample MAX_TIME = MAX_OBSERVED + OOS_MONTHS tnew = np.linspace(0, MAX_TIME, MAX_TIME)[:, None] . There is no presidential election on the forecasted horizon, so our new election_flag vector is all 0, which means it disappears from our regression. However, we need new unemployment data for the next three months -- and that&#39;s a bit more fun, because we get to be creative! . What are reasonable values? There are plenty of paths we could try. Conveniently, we&#39;re only forecasting one quarter, so we only need one data point for unemployment -- and then we&#39;ll add the random noise we inferred with our model (u_diff), so in reality we&#39;ll get 3 values that are close to each other. . The path we&#39;ll take here is very simple: let&#39;s assume that unemployment stays around its last value, with some noise equal to the standard deviation we observed in the sample. Let&#39;s write a small function to do all these steps easily and robustly: . log_unemp = np.log(d.unemployment) def generate_oos_unemp_data(center: float, oos_months: int) -&gt; np.ndarray: &quot;&quot;&quot; Generate out-of-sample unemployment data around `center` and for `oos_months`. &quot;&quot;&quot; # unemployment is around `center` ppc_unemp = np.random.normal( loc=center, scale=d.unemployment.std(), size=oos_months // 3, ) # data only observed quarterly, so need to forward-fill ppc_unemp = np.repeat(ppc_unemp, repeats=3) # log data and scale stdz_log_ppc_unemp = (np.log(ppc_unemp) - log_unemp.mean()) / log_unemp.std() # add noise around values return stdz_log_ppc_unemp + np.random.normal( loc=trace_econ.posterior[&quot;u_diff&quot;].mean(), scale=trace_econ.posterior[&quot;u_diff&quot;].std(), size=OOS_MONTHS, ) . oos_unemp = generate_oos_unemp_data( center=d.unemployment.iloc[-1], oos_months=OOS_MONTHS ) oos_unemp . array([0.45909571, 0.32365486, 0.31020988]) . Great, now let&#39;s generate predictions, shall we? This is pretty simple, we just have to give to PyMC3 our new $unemp _ data$, $election _ flag$ and time data. Then it will automatically sample 1,000 possible paths that the president&#39;s popularity could take in the coming 3 months, depending on the future values of unemployment. In other words, we will get 1,000 different timeseries that are all compatible with our prior knowledge and the data we got to observe -- Bayesian inference baby üòé . PREDICTION_COORDS = { &quot;timesteps&quot;: pd.date_range( start=COORDS[&quot;timesteps&quot;][0], end=COORDS[&quot;timesteps&quot;][-1] + pd.DateOffset(months=OOS_MONTHS), freq=&quot;M&quot;, ) } with econ_latent_gp: pm.set_data( { &quot;election_flag&quot;: np.concatenate( ( d.election_flag.values, np.zeros(OOS_MONTHS, dtype=int), ) ), &quot;stdz_log_unemployment&quot;: np.concatenate( (standardize(log_unemp).values, oos_unemp) ), } ) f_time_new = gp.conditional(&quot;f_time_new&quot;, Xnew=tnew) ppc = pm.sample_posterior_predictive( trace_econ.posterior, samples=1000, var_names=[&quot;baseline&quot;, &quot;f_time_new&quot;, &quot;honeymoon&quot;, &quot;log_unemp_effect&quot;], ) az.from_pymc3_predictions( ppc, idata_orig=trace_econ, inplace=True, coords=PREDICTION_COORDS, dims={&quot;f_time_new&quot;: [&quot;timesteps&quot;]}, ) . /Users/alex_andorra/opt/anaconda3/envs/elections-models/lib/python3.8/site-packages/pymc3/sampling.py:1707: UserWarning: samples parameter is smaller than nchains times ndraws, some draws and/or chains may not be represented in the returned posterior predictive sample warnings.warn( . . 100.00% [1000/1000 02:44&lt;00:00] And now we just plug these posterior predictive samples into our regression formula, to get back the predictive share of people who will approve of the president&#39;s job in the coming 3 months: . def compute_post_pred_approval( unemp_oos: xr.DataArray = trace_econ.predictions_constant_data[ &quot;stdz_log_unemployment&quot; ], ) -&gt; xr.DataArray: &quot;&quot;&quot; Compute job approval from posterior predictive samples. unemp_oos: out-of-sample values for unemployment. Defaults to the values stored in the `InferenceData.predictions_constant_data` group, i.e unemployment stays around last value. &quot;&quot;&quot; return logistic( trace_econ.predictions[&quot;baseline&quot;] + trace_econ.predictions[&quot;f_time_new&quot;] + trace_econ.predictions[&quot;honeymoon&quot;] * trace_econ.predictions_constant_data[&quot;election_flag&quot;] + trace_econ.predictions[&quot;log_unemp_effect&quot;] * unemp_oos ) . pp_prop = compute_post_pred_approval() . . . . . . . . &lt;xarray.DataArray (chain: 1, draw: 1000, timesteps: 228)&gt; array([[[0.46425858, 0.43908969, 0.49172391, ..., 0.37181162, 0.36931186, 0.36132396], [0.67062183, 0.57547055, 0.57300927, ..., 0.34953332, 0.3449213 , 0.34179501], [0.54908292, 0.49229414, 0.49772142, ..., 0.36848724, 0.38410193, 0.40365761], ..., [0.59844631, 0.48752805, 0.49632929, ..., 0.38263596, 0.37006839, 0.3655419 ], [0.59145529, 0.5339346 , 0.54851387, ..., 0.29139855, 0.27114263, 0.26186649], [0.6289814 , 0.52002421, 0.5108889 , ..., 0.3493696 , 0.32853289, 0.31408377]]]) Coordinates: * chain (chain) int64 0 * draw (draw) int64 0 1 2 3 4 5 6 7 ... 992 993 994 995 996 997 998 999 * timesteps (timesteps) datetime64[ns] 2002-05-31 2002-06-30 ... 2021-04-30 . xarray.DataArraychain: 1 | draw: 1000 | timesteps: 228 | . 0.4643 0.4391 0.4917 0.5433 0.5787 ... 0.3637 0.3494 0.3285 0.3141array([[[0.46425858, 0.43908969, 0.49172391, ..., 0.37181162, 0.36931186, 0.36132396], [0.67062183, 0.57547055, 0.57300927, ..., 0.34953332, 0.3449213 , 0.34179501], [0.54908292, 0.49229414, 0.49772142, ..., 0.36848724, 0.38410193, 0.40365761], ..., [0.59844631, 0.48752805, 0.49632929, ..., 0.38263596, 0.37006839, 0.3655419 ], [0.59145529, 0.5339346 , 0.54851387, ..., 0.29139855, 0.27114263, 0.26186649], [0.6289814 , 0.52002421, 0.5108889 , ..., 0.3493696 , 0.32853289, 0.31408377]]]) . | Coordinates: (3)chain(chain)int640array([0]) . | draw(draw)int640 1 2 3 4 5 ... 995 996 997 998 999array([ 0, 1, 2, ..., 997, 998, 999]) . | timesteps(timesteps)datetime64[ns]2002-05-31 ... 2021-04-30array([&amp;#x27;2002-05-31T00:00:00.000000000&amp;#x27;, &amp;#x27;2002-06-30T00:00:00.000000000&amp;#x27;, &amp;#x27;2002-07-31T00:00:00.000000000&amp;#x27;, ..., &amp;#x27;2021-02-28T00:00:00.000000000&amp;#x27;, &amp;#x27;2021-03-31T00:00:00.000000000&amp;#x27;, &amp;#x27;2021-04-30T00:00:00.000000000&amp;#x27;], dtype=&amp;#x27;datetime64[ns]&amp;#x27;) . | . | Attributes: (0) | . Great, we have computed posterior predictions and now have everything we need to plot them and see if they make sense. But first, what we can do for fun is use the same method as above to simulate posterior predictions for the cases when unemployment jumps to 10% or drops to 5% in the following quarter, instead of staying more or less the same. . Of course, this is not very realistic, as unemployment rarely changes that drastically, but this is to show-case how easy it is to generate counterfactuals in the Bayesian framework. It&#39;ll also allow us to further evaluate our model: if the different scenarios and their relative differences are consistent with our domain knowledge, this is another good point for our model. . oos_unemp_5 = generate_oos_unemp_data(center=5.0, oos_months=OOS_MONTHS) pp_prop_5 = compute_post_pred_approval( unemp_oos=xr.DataArray( np.concatenate((standardize(log_unemp).values, oos_unemp_5)), dims=[&quot;timesteps&quot;], coords=PREDICTION_COORDS, ) ) # unemployment jumps to 10% oos_unemp_10 = generate_oos_unemp_data(center=10.0, oos_months=OOS_MONTHS) pp_prop_10 = compute_post_pred_approval( unemp_oos=xr.DataArray( np.concatenate((standardize(log_unemp).values, oos_unemp_10)), dims=[&quot;timesteps&quot;], coords=PREDICTION_COORDS, ) ) . Ok, I can sense the suspense is at its peak now, so let&#39;s finally plot these predictions! The code is quite long, so I hid it by default, but the curious among you can expand it if they so wish. . _, (top, mid, low) = plt.subplots( 3, 1, figsize=(14, 12), constrained_layout=True, sharey=True ) pp_dates = pd.date_range( start=d.index[0] - np.timedelta64(0, &quot;M&quot;), periods=MAX_TIME, freq=&quot;M&quot;, ).values # plot the samples from the gp posterior with samples and shading pm.gp.util.plot_gp_dist( top, pp_prop.stack(sample=(&quot;chain&quot;, &quot;draw&quot;)).data.T, pp_dates, plot_samples=True, palette=&quot;viridis&quot;, fill_alpha=0.3, ) pm.gp.util.plot_gp_dist( mid, pp_prop_5.stack(sample=(&quot;chain&quot;, &quot;draw&quot;)).data.T, pp_dates, plot_samples=True, palette=&quot;cividis&quot;, fill_alpha=0.3, ) pm.gp.util.plot_gp_dist( low, pp_prop_10.stack(sample=(&quot;chain&quot;, &quot;draw&quot;)).data.T, pp_dates, plot_samples=True, palette=&quot;inferno&quot;, fill_alpha=0.3, ) for ax, cmap, title in zip( (top, mid, low), (plt.cm.viridis(0), plt.cm.cividis(0), plt.cm.inferno(0)), (f&quot;stays at {d.unemployment.iloc[-1]}%&quot;, &quot;drops to 5%&quot;, &quot;increases to 10%&quot;), ): # plot data ax.plot( raw_polls.index, raw_polls.p_approve.values, &quot;o&quot;, ms=4, color=cmap, alpha=0.3, label=&quot;Observed polls&quot;, ) # plot historical baseline ax.hlines( logistic(trace_econ.predictions[&quot;baseline&quot;].mean()), pp_dates[0], pp_dates[-1], &quot;k&quot;, &quot;-.&quot;, alpha=0.4, lw=2, ) ax.fill_between( pp_dates, logistic(az.hdi(trace_econ.predictions)[&quot;baseline&quot;]).sel(hdi=&quot;lower&quot;), logistic(az.hdi(trace_econ.predictions)[&quot;baseline&quot;]).sel(hdi=&quot;higher&quot;), color=&quot;k&quot;, edgecolor=&quot;none&quot;, alpha=0.1, ) ax.text( pd.to_datetime(&quot;2003-09-14&quot;), 0.3, &quot;Historical approval mean&quot;, fontsize=11, color=&quot;grey&quot;, horizontalalignment=&quot;center&quot;, ) # annotate graph ax.hlines( 0.5, pp_dates[0], pp_dates[-1], &quot;k&quot;, &quot;:&quot;, alpha=0.4, ) ax.vlines(pd.to_datetime(&quot;2002-05-14&quot;), 0.0, 0.9, &quot;k&quot;, &quot;--&quot;, alpha=0.4) ax.text( pd.to_datetime(&quot;2002-05-14&quot;), 0.9, &quot;Switch to 5-year term&quot;, fontsize=10, color=&quot;grey&quot;, horizontalalignment=&quot;center&quot;, ) ax.vlines(pd.to_datetime(&quot;2007-05-16&quot;), 0.0, 0.9, &quot;k&quot;, &quot;--&quot;, alpha=0.4) ax.text( pd.to_datetime(&quot;2007-05-16&quot;), 0.9, &quot;Sarkozy elected&quot;, fontsize=10, color=&quot;grey&quot;, horizontalalignment=&quot;center&quot;, ) ax.vlines(pd.to_datetime(&quot;2012-05-11&quot;), 0.0, 0.9, &quot;k&quot;, &quot;--&quot;, alpha=0.4) ax.text( pd.to_datetime(&quot;2012-05-11&quot;), 0.9, &quot;Hollande elected&quot;, fontsize=10, color=&quot;grey&quot;, horizontalalignment=&quot;center&quot;, ) ax.vlines(pd.to_datetime(&quot;2017-05-17&quot;), 0.0, 0.9, &quot;k&quot;, &quot;--&quot;, alpha=0.4) ax.text( pd.to_datetime(&quot;2017-05-17&quot;), 0.92, &quot;Macron elected&quot;, fontsize=10, color=&quot;grey&quot;, horizontalalignment=&quot;center&quot;, ) ax.vlines(pd.to_datetime(&quot;2020-01-24&quot;), 0.0, 0.9, &quot;k&quot;, &quot;--&quot;, alpha=0.4) ax.text( pd.to_datetime(&quot;2020-03-17&quot;), 0.91, &quot;1st Covid Cases&quot;, fontsize=10, color=&quot;grey&quot;, horizontalalignment=&quot;center&quot;, ) # axis labels and title ax.set_ylim((0, 1)) ax.set_xlabel(&quot;date&quot;) ax.set_ylabel(&quot;popularity in %&quot;) ax.set_title( f&quot;1 quarter out-of-sample, if unemployment {title}&quot;, fontsize=14, fontstyle=&quot;italic&quot;, ) ax.legend(fontsize=11, loc=&quot;lower left&quot;, frameon=True) plt.suptitle( &quot;Evolution of French presidents&#39; popularity over time&quot;, fontsize=14, fontweight=&quot;bold&quot;, ) plt.savefig(&quot;gp-popularity&quot;) . . Well I&#39;d say this is looking pretty good! As advertised, for each of the three counterfactuals, we got a whole distribution of time series -- 1,000 of them to be precise, each time series spanning from 2002 to the current month + one quarter. . This article was a tutorial to show you the model, so, for the lessons we can draw from this plot, let&#39;s go to the interactive version of this plot üòâ . . I hope you enjoyed this tutorial and that now you fancy trying out PyMC3 in your own domain -- if you also learned a thing or two about how French presidents&#39; popularity evolves with time, well that&#39;s even better! If you have any questions, suggestions, or spot a mistake somewhere (yeah, I&#39;m a pretty great man but I do make mistakes too -- 1.5 per year on average, to be precise), feel free to comment below or open an issue on the GitHub repo. . For anything else (especially immoderate praise), you can reach out on Twitter, and if you&#39;d like to learn more about Bayesian inference, feel free to check out my &quot;Learning Bayesian Statistics&quot; podcast, where I interview practitioners and researchers about why and how they use these methods. . Thanks for reading! Keep calm and PyMCheers üññ . PS: I wanted to leave you on a poetic note, so here is a list of the great packages I used to run this analysis üòç . xarray 0.16.0 arviz 0.10.0 numpy 1.19.1 pandas 1.0.5 pymc3 3.9.3 AlexAndorra last updated: Mon Jan 18 2021 CPython 3.8.5 IPython 7.19.0 .",
            "url": "https://alexandorra.github.io/pollsposition_blog/popularity/macron/gaussian%20processes/polls/2021/01/18/gp-popularity.html",
            "relUrl": "/popularity/macron/gaussian%20processes/polls/2021/01/18/gp-popularity.html",
            "date": " ‚Ä¢ Jan 18, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About",
          "content": "The PollsPosition project is an open-source endeavor with three main goals: . Exploring new statistical methods and applying them to real-life issues and datasets. This is a way for me to gain new skills and stay up to date with the field of Bayesian statistics, where the fun part is that you&#39;re never done learning! As such, I like to call PollsPosition my &quot;nerdy sandbox&quot; ü§ì Understanding how and why people make decisions when they don‚Äôt have all the facts is fascinating to me. That‚Äôs why I like, among others, electoral forecasting, and I use it as a sparring partner. | Popularizing and illustrating the power of Bayesian statistics. These are especially helpful in contexts where data are sparse and imprecise, domain knowledge is important, and estimating uncertainty is one of the main interest of the analysis. Well look at that: democratic elections check all these boxes ‚úÖ Icing on the cake, French political parties are numerous and change in nature -- compared to the US for instance -- which makes the models all the more complicated, but also... interesting! If you&#39;re curious, I presented a talk in 2020 about a version of the model: | A last, broader goal is to try to counteract our natural tendencies (especially during electoral campaigns!) to cherry-pick data, overreact to the latest poll, and, most importantly, completely misinterpret uncertainties and probabilities. I was invited on a podcast in 2020 to talk about just that, if that&#39;s of interest to you üìª I&#39;m perfectly aware that it&#39;s a lofty and probably unattainable goal. I do believe that spreading the methods of rational and critical thinking is essential though, so I can at least try ü§∑‚Äç‚ôÇ For sure, I can&#39;t do it alone, so if you like what we do at PollsPosition, feel free to share our content with your friends and colleagues -- or if you don&#39;t like it, share it with people you don&#39;t like, that works too! The Local Maximum ¬∑ Ep. 140 - Why Polls are Tricky with Alex Andorra | If this all sounds fun to you and you&#39;re looking for a project to improve your Python and Bayesian chops, feel free to contribute pull requests -- there is always something to do! . My name is Alexandre Andorra by the way. By day, I&#39;m a Bayesian modeler at the PyMC Labs consultancy and host the most popular podcast dedicated to Bayesian inference out there -- aka Learning Bayesian Statistics . By night, I don&#39;t (yet) fight crime, but I&#39;m an open-source enthusiast and core contributor to the awesome Python packages PyMC and ArviZ . . An always-learning statistician, I love building models and studying elections and human behavior. I also love Nutella a bit too much, but I don&#39;t like talking about it ‚Äì I prefer eating it üòã . I can&#39;t finish without acknowledging the people who help me in this nerdy adventure, most notably the brilliant Alexis Berg√®s who devises with me for hours about ways to best model elections, as well as the wonderful core-developers of ArviZ and PyMC, who often indulge my unrelenting stats questions ü§© . Feel free to reach out on Twitter if you want to talk about chocolate, statistical modeling under certainty, or how &quot;polls are useless now because they missed two elections in a row!&quot; -- yeah, I&#39;m a bit sarcastic. .",
          "url": "https://alexandorra.github.io/pollsposition_blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ ‚Äúsitemap.xml‚Äù | absolute_url }} | .",
          "url": "https://alexandorra.github.io/pollsposition_blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}